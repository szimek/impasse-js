// Generated by CoffeeScript 2.7.0
(function() {
  // Helper for defining getters/setters in CoffeeScript - https://gist.github.com/1599437
  var error, storage,
    indexOf = [].indexOf;

  Function.prototype.define = function(prop, desc) {
    return Object.defineProperty(this.prototype, prop, desc);
  };

  // Hack for localStorage in Mobile Safari private browsing mode
  storage = window.localStorage;

  try {
    storage.setItem("testPrivateBrowsingMode", "1");
    storage.removeItem("testPrivateBrowsingMode");
  } catch (error1) {
    error = error1;
    if (error.code === DOMException.QUOTA_EXCEEDED_ERR && storage.length === 0) {
      storage = {};
    } else {
      throw error;
    }
  }

  window.ig = {
    game: null,
    KEY: {
      LEFT: 37,
      UP: 38,
      RIGHT: 39,
      DOWN: 40,
      SHIFT: 16,
      HYPHEN: 173,
      EQUAL: 61,
      PLUS: 187,
      MINUS: 189
    },
    DIRECTION: {
      LEFT: 37,
      UP: 38,
      RIGHT: 39,
      DOWN: 40
    }
  };

  ig.Game = (function() {
    class Game {
      constructor(options = {}) {
        var debouncedAfterPlayerMoved, fullscreenFn;
        this._onKeyDown = this._onKeyDown.bind(this);
        ig.game = this;
        storage["completedLevels"] || (storage["completedLevels"] = JSON.stringify([]));
        // Create required DOM elements and draw the initial state of the game
        // (without title, tiles etc.) before a level is loaded
        this._createLayout();
        // Load the initial level without fade-in
        this.loadLevel(this.currentLevelIndex, false);
        if (options.fullscreen) {
          window.addEventListener("orientationchange", (event) => {
            return this._rescaleLayout();
          });
          this._rescaleLayout();
        }
        // Handle player input
        this._isCurrentlyPressed = {};
        document.addEventListener("keydown", (event) => {
          var key;
          key = event.which;
          if (!this._isCurrentlyPressed[key]) {
            this._onKeyDown(event);
          }
          return this._isCurrentlyPressed[key] = true;
        });
        document.addEventListener("keyup", (event) => {
          return this._isCurrentlyPressed[event.which] = false;
        });
        if (options.touch) {
          // Disable scrolling on iOS. It also disables zooming.
          document.ontouchmove = function(event) {
            return event.preventDefault();
          };
          ["swipeLeft", "swipeRight", "swipeUp", "swipeDown"].forEach((eventName) => {
            return $(this.dom.overlay).on(eventName, (event) => {
              this._onSwipe(event);
              return event.preventDefault();
            });
          });
          // Use Array#filter because of lack of Array#find
          fullscreenFn = ["requestFullscreen", "mozRequestFullScreen", "webkitRequestFullscreen"].filter((fnName) => {
            return this.dom.game[fnName];
          })[0];
          if (fullscreenFn) {
            $(this.dom.game).on("doubleTap", (event) => {
              return this.dom.game[fullscreenFn]();
            });
          }
        }
        // Hackish way to ensure that @_afterPlayerMoved is called just once
        debouncedAfterPlayerMoved = $.debounce(100, true, (event) => {
          return this._afterPlayerMoved();
        });
        ["transitionend", "webkitTransitionEnd", "oTransitionEnd"].forEach((eventName) => {
          return this.dom.board.addEventListener(eventName, function(event) {
            var entity;
            entity = event.target;
            if (entity.classList.contains("player")) {
              return debouncedAfterPlayerMoved(event);
            }
          });
        });
      }

      update(direction) {
        var blocks, collidingBlocks, level, player, playerHasMoved;
        level = this.currentLevel;
        player = level.player;
        blocks = level.blocks;
        if ((playerHasMoved = player.update(direction))) {
          blocks.forEach(function(block) {
            block.uncover(); // TODO move into Entity#update method
            return block.update(direction);
          });
          blocks.forEach(function(block) {
            if (block.isCovered(blocks)) {
              return block.cover();
            }
          });
          // Check collisions
          collidingBlocks = this._checkPlayerCollision();
          collidingBlocks.forEach((block) => {
            return this._onPlayerCollision(block);
          });
        }
        return playerHasMoved;
      }

      draw() {
        var level;
        level = this.currentLevel;
        level.blocks.forEach(function(block) {
          return block.draw();
        });
        return level.player.draw();
      }

      loadLevel(levelNumber, fadeIn = true) {
        var blocks, board, level, mapping, player;
        // Reset game state
        this.isLevelOver = false;
        this.isGameOver = false;
        this.isPlayerMoving = false;
        mapping = ig.Game.entitiesMapping;
        level = ig.Game.levels[levelNumber];
        board = ig.Game.board;
        player = null;
        blocks = [];
        this._resetLayout(levelNumber);
        // Initialize all blocks and append them to the DOM
        level.data.split("").forEach(function(id, i) {
          var entity, klass, x, y;
          // Skip empty cells
          if (id !== "0") {
            x = i % board.width; // e.g. 12 % 10 = 2
            y = (i - x) / board.width; // e.g. (12 - 2) / 10 = 1
            klass = mapping[id];
            entity = new ig[klass](x, y);
            if (id === "1") {
              return player = entity;
            } else {
              return blocks.push(entity);
            }
          }
        });
        this.currentLevel = {
          number: levelNumber,
          name: level.name,
          player: player,
          blocks: blocks
        };
        // Set the initial position of DOM elements on the board
        this.draw();
        return this.currentLevel;
      }

      _createLayout() {
        var board, game, levelProgress, overlay, title;
        game = document.getElementById("impasse");
        overlay = document.createElement("div");
        overlay.className = "overlay";
        title = document.createElement("div");
        title.className = "row title";
        board = document.createElement("div");
        board.className = "row board";
        levelProgress = document.createElement("div");
        levelProgress.className = "row level_progress";
        this.dom = {
          document: document,
          game: game,
          overlay: game.appendChild(overlay),
          title: game.appendChild(title),
          board: game.appendChild(board),
          levelProgress: game.appendChild(levelProgress)
        };
        // Create level progress markers
        return ig.Game.levels.forEach((level, index) => {
          var el;
          el = document.createElement("div");
          el.dataset.levelIndex = index;
          el.className = "point";
          return this.dom.levelProgress.appendChild(el);
        });
      }

      _resetLayout(levelNumber) {
        var completedLevels, el, j, len, level, point, points, ref;
        level = ig.Game.levels[levelNumber];
        this.dom.game.classList.remove("game_over");
        // Remove all existing blocks from DOM
        this.dom.board.innerHTML = "";
        // Update level title in DOM
        this.dom.title.innerHTML = level.name;
        // Update level progress markers in DOM
        completedLevels = JSON.parse(storage["completedLevels"]);
        points = this.dom.levelProgress.getElementsByClassName("point");
        for (j = 0, len = points.length; j < len; j++) {
          el = points[j];
          el.classList.remove("active");
          if (ref = Number(el.dataset.levelIndex), indexOf.call(completedLevels, ref) >= 0) {
            el.classList.add("completed");
          }
        }
        point = this.dom.levelProgress.querySelector(`.point[data-level-index='${levelNumber}']`);
        return point.classList.add("active");
      }

      _rescaleLayout() {
        var game, scale;
        game = $(this.dom.game);
        game.css(`${$.fx.cssPrefix}transform`, "scale(1)");
        scale = window.innerWidth / 600;
        return game.css(`${$.fx.cssPrefix}transform`, `scale(${scale})`);
      }

      _onKeyDown(event) {
        var direction, key;
        if (!(this.isPlayerMoving || this.isLevelOver || this.isGameOver)) {
          switch (key = event.which) {
            case ig.KEY.PLUS:
            case ig.KEY.EQUAL:
              if (!this._isCurrentlyPressed[ig.KEY.SHIFT]) {
                break;
              }
              this.currentLevelIndex += 1;
              this._onLevelOver();
              return event.preventDefault();
            case ig.KEY.MINUS:
            case ig.KEY.HYPHEN:
              if (!this._isCurrentlyPressed[ig.KEY.SHIFT]) {
                break;
              }
              this.currentLevelIndex -= 1;
              this._onLevelOver();
              return event.preventDefault();
            case ig.KEY.LEFT:
            case ig.KEY.UP:
            case ig.KEY.RIGHT:
            case ig.KEY.DOWN:
              direction = key;
              this.isPlayerMoving = this.update(direction);
              if (this.isPlayerMoving) {
                this.draw();
              }
              return event.preventDefault();
          }
        }
      }

      _onSwipe(event) {
        var direction;
        if (!(this.isPlayerMoving || this.isLevelOver || this.isGameOver)) {
          direction = (function() {
            switch (event.type) {
              case "swipeLeft":
                return ig.DIRECTION.LEFT;
              case "swipeUp":
                return ig.DIRECTION.UP;
              case "swipeRight":
                return ig.DIRECTION.RIGHT;
              case "swipeDown":
                return ig.DIRECTION.DOWN;
            }
          })();
          this.isPlayerMoving = this.update(direction);
          if (this.isPlayerMoving) {
            return this.draw();
          }
        }
      }

      _afterPlayerMoved(event) {
        // Enable entity animation that may have been disabled by its update method
        Array.prototype.slice.call(this.dom.board.children).forEach(function(el) {
          return el.classList.remove("no_transition");
        });
        if (this.isGameOver) {
          this._onGameOver();
        } else if (this.isLevelOver) {
          this._onLevelOver();
        }
        return this.isPlayerMoving = false;
      }

      _checkPlayerCollision() {
        var level;
        level = this.currentLevel;
        return level.blocks.filter(function(block) {
          return level.player.doesCollideWith(block);
        });
      }

      _onPlayerCollision(block) {
        switch (block.constructor) {
          case ig.GreenOBlock:
            return this._onGreenOBlockCollision(block);
          case ig.WinBlock:
            this._onWinBlockCollision(block);
            return this.isLevelOver = true;
          default:
            return this.isLevelOver = true;
        }
      }

      _onGreenOBlockCollision(block) {
        block.isPresent = false;
        // Toggle presence of all red x block on the level
        return this.currentLevel.blocks.forEach(function(el) {
          if (el instanceof ig.RedXBlock) {
            return el.isPresent = !el.isPresent;
          }
        });
      }

      _onWinBlockCollision(block) {
        var completedLevels;
        if (this.currentLevelIndex === ig.Game.levels.length - 1) {
          return this.isGameOver = true;
        } else {
          completedLevels = JSON.parse(storage["completedLevels"]);
          if (completedLevels.indexOf(this.currentLevelIndex) === -1) {
            completedLevels.push(this.currentLevelIndex);
            storage["completedLevels"] = JSON.stringify(completedLevels);
          }
          return this.currentLevelIndex += 1;
        }
      }

      _onLevelOver() {
        var onTransitionEnd, self;
        self = this;
        onTransitionEnd = function(event) {
          var overlay;
          // Restart the current level or load the next one
          self.loadLevel(self.currentLevelIndex);
          // Hide faded-in overlay without transition
          overlay = self.dom.overlay;
          overlay.classList.add("no_transition");
          overlay.style.opacity = 0;
          overlay.classList.remove("no_transition");
          // Remove this listener to make sure it's executed just once per #_onLevelOver call
          return overlay.removeEventListener(event.type, onTransitionEnd);
        };
        ["transitionend", "webkitTransitionEnd", "oTransitionEnd"].forEach((eventName) => {
          return this.dom.overlay.addEventListener(eventName, onTransitionEnd);
        });
        // Fade in the overlay
        return this.dom.overlay.style.opacity = 1;
      }

      _onGameOver() {
        this.dom.game.classList.add("game_over");
        return this.dom.board.innerHTML = `You've reached the end of this puzzling journey.
<br>
Looking forward to travelling with you again!
<br><br>
Regards, Wanderlands`;
      }

    };

    Game.entitiesMapping = {
      "1": "Player",
      "2": "StaticBlock",
      "3": "OrangeUpBlock",
      "4": "PurpleDownBlock",
      "5": "YellowUpBlock",
      "6": "BlueDownBlock",
      "7": "BlueMinusBlock",
      "8": "WinBlock",
      "9": "PinkMinusBlock",
      "a": "RedXBlock",
      "b": "GreenOBlock"
    };

    Game.levels = [
      {
        name: "motion",
        data: "002000000010200002080000000200"
      },
      {
        name: "pathway",
        data: "222200022210200202082000220002"
      },
      {
        name: "wrap",
        data: "002000020010222222080000220000"
      },
      {
        name: "surprise",
        data: "000033030010300003080030330000"
      },
      {
        name: "going up",
        data: "020002000212323002380032322232"
      },
      {
        name: "phase",
        data: "000032000010323003280230003322"
      },
      {
        name: "weave",
        data: "004040204013424323480302030300"
      },
      {
        name: "lock",
        data: "240032400210343442382224000332"
      },
      {
        name: "bridge",
        data: "040322403014333444380020000200"
      },
      {
        name: "flash",
        data: "002020700210702027780020702002"
      },
      {
        name: "deception",
        data: "020703020217324327480207427742"
      },
      {
        name: "sidestep",
        data: "237237320217007070480372370242"
      },
      {
        name: "offbeat",
        data: "000970790010790970080070790900"
      },
      {
        name: "hurdle",
        data: "090702000212473243280242909270"
      },
      {
        name: "backdoor",
        data: "027702030712329342280992939307"
      },
      {
        name: "axis",
        data: "000205200212504500080200402552"
      },
      {
        name: "sweep",
        data: "025555555210000003080207040302"
      },
      {
        name: "gate",
        data: "000220570012520453580207040352"
      },
      {
        name: "unzip",
        data: "005634560010000000080056345600"
      },
      {
        name: "twins",
        data: "076049503212654256380905070602"
      },
      {
        name: "machine",
        data: "304030403012452245283670367036"
      },
      {
        name: "reduction",
        data: "00ba039200100a0b66a800ba030b20"
      },
      {
        name: "lure",
        data: "009630b2201256356ba8005ba50220"
      },
      {
        name: "final dance",
        data: "05ba052222106079bba80560602222"
      }
    ];

    Game.board = {
      height: 3,
      width: 10
    };

    Game.define('currentLevelIndex', {
      get: function() {
        return Number(this._currentLevelIndex || storage["currentLevel"] || 0);
      },
      set: function(value) {
        var index;
        index = Number(value);
        if (index < 0) {
          this._currentLevelIndex = 0;
        } else if (index >= ig.Game.levels.length) {
          this._currentLevelIndex = ig.Game.levels.length - 1;
        } else {
          this._currentLevelIndex = index;
        }
        return storage["currentLevel"] = this._currentLevelIndex;
      }
    });

    Game.prototype.currentLevel = void 0;

    Game.prototype.isLevelOver = false;

    Game.prototype.isGameOver = false;

    return Game;

  }).call(this);

  ig.Entity = (function() {
    class Entity {
      constructor(x, y) {
        var dom;
        dom = ig.game.dom;
        this.pos = {
          x: x,
          y: y
        };
        this.el = [1, 2, 3].map((item) => {
          var el;
          el = dom.document.createElement("div");
          el.className = `entity ${this.constructor.className}`;
          el.style.zIndex = this.constructor.zIndex;
          dom.board.appendChild(el);
          return el;
        });
        this.isPresent = true;
      }

      update(direction) {
        return false;
      }

      // Change position of DOM elements - animation is handled by CSS transitions.
      draw() {
        var blockDiameter, margin, totalDiameter;
        margin = 8;
        blockDiameter = 44;
        totalDiameter = 2 * margin + blockDiameter;
        return this.el.forEach((el, index) => {
          var offset;
          index -= 1; // map [0, 1, 2] to [-1, 0, +1]
          offset = index * ig.Game.board.height * totalDiameter;
          el.style.top = (margin + this.pos.y * totalDiameter) + offset + "px";
          return el.style.left = (margin + this.pos.x * totalDiameter) + "px";
        });
      }

      doesCollideWith(other) {
        return other.isPresent && this.pos.x === other.pos.x && this.pos.y === other.pos.y;
      }

      isCovered(blocks) {
        var others;
        others = blocks.filter((block) => {
          if (this !== block && this.doesCollideWith(block)) {
            return true;
          }
        });
        // Sorting is not really needed, as it's probably not possible to
        // have more than 2 blocks at the same position
        if (others.length) {
          others.sort(function(a, b) {
            return a.constructor.zIndex - b.constructor.zIndex;
          });
          return this.constructor.zIndex < others[0].constructor.zIndex;
        } else {
          return false;
        }
      }

      cover() {
        return this.el.forEach(function(el) {
          return el.classList.add("covered");
        });
      }

      uncover() {
        return this.el.forEach(function(el) {
          return el.classList.remove("covered");
        });
      }

      _up() {
        var el;
        this.pos.y -= 1;
        if (this.pos.y === -1) {
          this.pos.y = ig.Game.board.height - 1;
          el = this.el.shift();
          this.el.push(el);
          return el.classList.add("no_transition");
        }
      }

      _down() {
        var el;
        this.pos.y += 1;
        if (this.pos.y === ig.Game.board.height) {
          this.pos.y = 0;
          el = this.el.pop();
          this.el.unshift(el);
          return el.classList.add("no_transition");
        }
      }

    };

    Entity.id = "0";

    Entity.zIndex = 0;

    Entity.className = "";

    Entity.showBorderWhenHidden = false;

    Entity.define('isPresent', {
      get: function() {
        return this._present;
      },
      set: function(value) {
        var method;
        this._present = Boolean(value);
        method = this._present ? "remove" : "add";
        this.el.forEach(function(el) {
          return el.classList[method]("hidden");
        });
        return this;
      }
    });

    return Entity;

  }).call(this);

  ig.Player = (function() {
    class Player extends ig.Entity {
      update(direction) {
        switch (direction) {
          case ig.KEY.LEFT:
            if (this.pos.x === 0) {
              return false;
            }
            this.pos.x -= 1;
            return true;
          case ig.KEY.RIGHT:
            if (this.pos.x === ig.Game.board.width - 1) {
              return false;
            }
            this.pos.x += 1;
            return true;
          case ig.KEY.UP:
            this._up();
            return true;
          case ig.KEY.DOWN:
            this._down();
            return true;
        }
      }

    };

    Player.id = "1";

    Player.zIndex = 5;

    Player.className = "player";

    return Player;

  }).call(this);

  ig.StaticBlock = (function() {
    class StaticBlock extends ig.Entity {};

    StaticBlock.id = "2";

    StaticBlock.className = "static";

    return StaticBlock;

  }).call(this);

  ig.OrangeUpBlock = (function() {
    class OrangeUpBlock extends ig.Entity {
      update(direction) {
        switch (direction) {
          case ig.KEY.LEFT:
          case ig.KEY.RIGHT:
            return false;
          case ig.KEY.UP:
          case ig.KEY.DOWN:
            this._up();
            return true;
        }
      }

    };

    OrangeUpBlock.id = "3";

    OrangeUpBlock.zIndex = 2;

    OrangeUpBlock.className = "orange_up_block";

    return OrangeUpBlock;

  }).call(this);

  ig.PurpleDownBlock = (function() {
    class PurpleDownBlock extends ig.Entity {
      update(direction) {
        switch (direction) {
          case ig.KEY.LEFT:
          case ig.KEY.RIGHT:
            return false;
          case ig.KEY.UP:
          case ig.KEY.DOWN:
            this._down();
            return true;
        }
      }

    };

    PurpleDownBlock.id = "4";

    PurpleDownBlock.zIndex = 2;

    PurpleDownBlock.className = "purple_down_block";

    return PurpleDownBlock;

  }).call(this);

  ig.YellowUpBlock = (function() {
    class YellowUpBlock extends ig.Entity {
      update(direction) {
        switch (direction) {
          case ig.KEY.LEFT:
          case ig.KEY.RIGHT:
            this._up();
            return true;
          case ig.KEY.UP:
          case ig.KEY.DOWN:
            return false;
        }
      }

    };

    YellowUpBlock.id = "5";

    YellowUpBlock.zIndex = 3;

    YellowUpBlock.className = "yellow_up_block";

    return YellowUpBlock;

  }).call(this);

  ig.BlueDownBlock = (function() {
    class BlueDownBlock extends ig.Entity {
      update(direction) {
        switch (direction) {
          case ig.KEY.LEFT:
          case ig.KEY.RIGHT:
            this._down();
            return true;
          case ig.KEY.UP:
          case ig.KEY.DOWN:
            return false;
        }
      }

    };

    BlueDownBlock.id = "6";

    BlueDownBlock.zIndex = 3;

    BlueDownBlock.className = "blue_down_block";

    return BlueDownBlock;

  }).call(this);

  ig.BlueMinusBlock = (function() {
    class BlueMinusBlock extends ig.Entity {
      update(direction) {
        switch (direction) {
          case ig.KEY.LEFT:
          case ig.KEY.RIGHT:
            return false;
          case ig.KEY.UP:
          case ig.KEY.DOWN:
            this.isPresent = !this.isPresent;
            return true;
        }
      }

    };

    BlueMinusBlock.id = "7";

    BlueMinusBlock.zIndex = 4;

    BlueMinusBlock.className = "blue_minus_block hideable";

    return BlueMinusBlock;

  }).call(this);

  ig.WinBlock = (function() {
    class WinBlock extends ig.Entity {};

    WinBlock.id = "8";

    WinBlock.className = "win_block";

    return WinBlock;

  }).call(this);

  ig.PinkMinusBlock = (function() {
    class PinkMinusBlock extends ig.Entity {
      constructor(x, y) {
        super(x, y);
        this.isPresent = false;
      }

      update(direction) {
        switch (direction) {
          case ig.KEY.LEFT:
          case ig.KEY.RIGHT:
            return false;
          case ig.KEY.UP:
          case ig.KEY.DOWN:
            this.isPresent = !this.isPresent;
            return true;
        }
      }

    };

    PinkMinusBlock.id = "9";

    PinkMinusBlock.zIndex = 4;

    PinkMinusBlock.className = "pink_minus_block hideable";

    return PinkMinusBlock;

  }).call(this);

  ig.RedXBlock = (function() {
    class RedXBlock extends ig.Entity {};

    RedXBlock.id = "a";

    RedXBlock.zIndex = 4;

    RedXBlock.className = "red_x_block hideable";

    RedXBlock.showBorderWhenHidden = true;

    return RedXBlock;

  }).call(this);

  ig.GreenOBlock = (function() {
    class GreenOBlock extends ig.Entity {};

    GreenOBlock.id = "b";

    GreenOBlock.zIndex = 4;

    GreenOBlock.className = "green_o_block";

    return GreenOBlock;

  }).call(this);

}).call(this);

//# sourceMappingURL=impasse.js.map
